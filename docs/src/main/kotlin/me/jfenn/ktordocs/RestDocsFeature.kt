package me.jfenn.ktordocs

/*import io.ktor.application.*
import io.ktor.auth.AuthenticationProvider
import io.ktor.auth.AuthenticationRouteSelector
import io.ktor.http.ContentType
import io.ktor.response.respondText
import io.ktor.routing.**/
import io.ktor.server.auth.*
import io.ktor.server.routing.*
import io.ktor.util.AttributeKey
import io.ktor.util.pipeline.PipelineContext
import io.ktor.util.pipeline.PipelineInterceptor
import kotlinx.coroutines.GlobalScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch
import me.jfenn.ktordocs.model.Configuration
import me.jfenn.ktordocs.model.EndpointInfo
import me.jfenn.ktordocs.model.ParameterInfo
import kotlin.coroutines.CoroutineContext
import kotlin.reflect.full.memberProperties

class RestDocsFeature(
    val docs: RestDocs
) {

    private fun buildPathString(selectors: List<RouteSelector>, defaultParam: String? = null) : String {
        return "/" + selectors.mapNotNull {
            when (it) {
                is PathSegmentConstantRouteSelector -> it.value
                is PathSegmentParameterRouteSelector -> defaultParam ?: "{${it.name}}"
                is PathSegmentOptionalParameterRouteSelector -> defaultParam ?: "{${it.name}?}"
                is PathSegmentTailcardRouteSelector -> defaultParam ?: "{...${it.name}}"
                is PathSegmentWildcardRouteSelector -> defaultParam ?: "*"
                else -> null
            }
        }.joinToString("/")
    }

    suspend fun updateRoutes(route: Route, selectors: List<RouteSelector> = listOf(), inheritEndpoint: EndpointInfo = docs.config.defaultEndpoint) {
        var newEndpoint = inheritEndpoint

        (route.selector as? AuthenticationRouteSelector)?.let { selector ->
            // add auth methods
            newEndpoint = inheritEndpoint.copy(
                authentication = selector.names.filterNotNull()
            ).apply {
                selector.names.firstOrNull()?.let {
                    docs.config.authMethods[it]
                }?.also {
                    params.putAll(it.params)
                }
            }
        }

        (route.selector as? HttpMethodRouteSelector)?.let { selector ->
            val path = buildPathString(selectors)
            val endpoint = inheritEndpoint.copy(
                path = path,
                method = selector.method
            )

            // insert known path params
            selectors.forEach {
                when (it) {
                    is PathSegmentParameterRouteSelector -> endpoint.param(it.name) {
                        location = ParameterInfo.In.Path
                        isRequired = true
                    }
                    is PathSegmentOptionalParameterRouteSelector -> endpoint.param(it.name) {
                        location = ParameterInfo.In.Path
                    }
                    is PathSegmentTailcardRouteSelector -> endpoint.param(it.name) {
                        location = ParameterInfo.In.Path
                        isRequired = true
                        type = "vararg"
                    }
                }
            }

            // using reflection to obtain the "route.handlers" property
           val handlers = Route::class.memberProperties.find {
               it.name == "handlers"
           }?.get(route) as ArrayList<PipelineInterceptor<Unit, ApplicationCall>>

            handlers.forEach {
                try { // try to invoke each handler
                    DummyPipelineContext.it(Unit)
                } catch (e: DocsProxyException) {
                    // caught proxy extension; add endpoint to docs
                    e.configure.invoke(endpoint)
                    docs.endpoint(endpoint)
                    return
                } catch (e: Throwable) {
                    // do nothing
                }
            }
        }

        route.children.forEach {
            updateRoutes(it, selectors + it.selector, newEndpoint)
        }
    }

    companion object : ApplicationFeature<Application, Configuration, RestDocsFeature> {

        override val key = AttributeKey<RestDocsFeature>("Ktor REST Documentation")

            override fun install(pipeline: Application, configure: Configuration.() -> Unit) : RestDocsFeature {
            val docs = RestDocs {
                configure()
            }

            return RestDocsFeature(docs)
        }

    }

}


/**
 * Hosts the API documentation generated by the library
 * at the specified path.
 */
fun Route.restDocumentation(path: String = "/") {
    GlobalScope.launch {
        delay(500)
        application.feature(RestDocsFeature).updateRoutes(this@restDocumentation)
    }

    get(path) {
        application.feature(RestDocsFeature).apply {
            call.respondText(docs.htmlBuilder.toHtml(), ContentType.Text.Html)
        }
    }
}

/**
 * Provides documentation for a particular endpoint.
 * Should be invoked at the start of the request handler.
 *
 * Under normal conditions, this function call does
 * nothing.
 */
fun PipelineContext<Unit, ApplicationCall>.docs(configure: EndpointInfo.() -> Unit) {
    if (this is DummyPipelineContext)
        throw DocsProxyException(configure)
}

class DocsProxyException(
    val configure: EndpointInfo.() -> Unit
) : RuntimeException("default ktor docs behavior")

object DummyPipelineContext : PipelineContext<Unit, ApplicationCall> {
    override val context: ApplicationCall
        get() = TODO("Not yet implemented")
    override val coroutineContext: CoroutineContext
        get() = TODO("Not yet implemented")
    override val subject: Unit
        get() = TODO("Not yet implemented")

    override fun finish() {
        TODO("Not yet implemented")
    }

    override suspend fun proceed() {
        TODO("Not yet implemented")
    }

    override suspend fun proceedWith(subject: Unit) {
        TODO("Not yet implemented")
    }
}
